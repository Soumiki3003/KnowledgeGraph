{
  "id": "CTF_KG",
  "name": "Central node",
  "children": [
    {
      "id": "C01",
      "name": "Angr Project Initialization",
      "label": "Concept 1",
      "definition": "Understanding how to initialize an Angr project and create an initial symbolic state for execution.",
      "difficulty": "beginner",
      "bloom_level": "Understand",
      "prerequisites": [],
      "misconceptions": ["Assuming angr loads libraries automatically", "Using full_init_state instead of entry_state"],
      "visibility": ["supervisor_agent", "instructor"],
      "validation_status": "verified",
      "confidence": 0.93,
      "relevance_score": 0.82,
      "source": "CTF_copy.pdf [page 5]",
      "learning_objective": "Set up an angr project and create a simulation state.",
      "connections": [
        {"to": "C02", "relation": "PREREQUISITE_FOR"}
      ],
      "children": [
        {
          "id": "P01",
          "name": "Procedural steps: Angr Initialization",
          "label": "Procedural Steps",
          "description": "Procedure for initializing an angr project and creating a symbolic state.",
          "difficulty": "beginner",
          "bloom_level": "Apply",
          "common_errors": ["Wrong binary path", "Using wrong initialization state"],
          "success_criteria": ["Project loads correctly", "Initial symbolic state created"],
          "error_patterns": ["FileNotFoundError", "AttributeError: 'Project' object has no attribute"],
          "progress_metric": {"completed": false, "percent_done": 0},
          "children": [
            {
              "id": "P01-step1",
              "name": "Step 1: Import angr and load binary",
              "label": "Procedural Step 1",
              "code_snippet": "import angr\nproject = angr.Project('challenge_binary', auto_load_libs=False)",
              "hint": "Ensure angr is installed; disable auto_load_libs to save memory.",
              "children": [
                {
                  "id": "P01-step2",
                  "name": "Step 2: Create initial symbolic state",
                  "code_snippet": "state = project.factory.entry_state()",
                  "hint": "entry_state() begins at the binary entry point."
                }
              ]
            }
          ]
        },
        {
          "id": "A01",
          "name": "Assessment Guide: Angr Initialization",
          "label": "Assessment 1",
          "linked_challenges": ["00_angr_find"],
          "objectives": [
            "Load binary in angr",
            "Initialize a correct symbolic state"
          ],
          "question_prompts": [
            {"question": "Which function creates a symbolic start state?"},
            {"question": "What happens if you use full_init_state()?"}
          ],
          "evaluation_criteria": [
            "Binary loads without crash",
            "State includes symbolic stdin"
          ],
          "bloom_level": "Evaluate",
          "difficulty": "beginner"
        }
      ]
    },
    {
      "id": "C02",
      "name": "Find and Avoid Algorithm",
      "definition": "Technique for identifying exploration targets in disassembly.",
      "label": "Concept 2",
      "difficulty": "intermediate",
      "bloom_level": "Apply",
      "prerequisites": ["C01"],
      "misconceptions": ["Find/avoid works automatically", "Using string address instead of code address"],
      "visibility": ["supervisor_agent", "instructor"],
      "validation_status": "verified",
      "confidence": 0.91,
      "relevance_score": 0.88,
      "source": "CTF_copy.pdf [page 9]",
      "learning_objective": "Use disassembly evidence to locate and configure find/avoid targets.",
      "connections": [
        {"to": "C01", "relation": "DEPENDS_ON"},
        {"to": "C03", "relation": "EXTENDS_TO"}
      ],
      "children": [
        {
          "id": "P02",
          "name": "Procedural Steps: Find/Avoid Algorithm",
          "label": "Procedural Steps",
          "description": "Procedure for extracting disassembly targets and configuring angr exploration.",
          "difficulty": "intermediate",
          "bloom_level": "Apply",
          "common_errors": [
            "Choosing unreachable addresses",
            "Incorrect explore() syntax"
          ],
          "success_criteria": [
            "Correct find/avoid addresses chosen",
            "Program reaches success function"
          ],
          "error_patterns": [
            "angr.SimManager Error",
            "InvalidAddressException"
          ],
          "progress_metric": {"completed": false, "percent_done": 0},
          "children": [
            {
              "id": "P02-step1",
              "name": "Step 1: Search for success message in disassembly",
              "label": "Procedural Step 1",
              "code_snippet": "objdump -d binary | grep 'puts'",
              "hint": "Look for string references near 'Success'.",
              "children": [
                {
                  "id": "P02-step2",
                  "name": "Step 2: Find call site printing success message",
                  "label": "Procedural Step 2",
                  "code_snippet": "grep -n 'puts' binary.asm",
                  "hint": "Locate printf or puts thunks.",
                  "children": [
                    {
                      "id": "P02-step3",
                      "name": "Step 3: Record relevant instruction addresses",
                      "label": "Procedural Step 3",
                      "hint": "Mark addresses for find/avoid targets.",
                      "children": [
                        {
                          "id": "P02-step4",
                          "name": "Step 4: Configure find/avoid in explore()",
                          "label": "Procedural Step 4",
                          "code_snippet": "simgr.explore(find=success_addr, avoid=fail_addr)",
                          "hint": "Ensure both parameters are defined."
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "id": "A02",
          "name": "Assessment Guide: Find/Avoid Algorithm",
          "label": "Assessment 2",
          "linked_challenges": ["02_angr_find_condition"],
          "objectives": [
            "Apply find/avoid correctly",
            "Link disassembly evidence to execution flow"
          ],
          "question_prompts": [
            {"question": "Why define both find and avoid addresses?"},
            {"question": "What happens if the avoid address is missed?"}
          ],
          "evaluation_criteria": [
            "Reaches correct success path",
            "Avoids failure outputs"
          ],
          "bloom_level": "Evaluate",
          "difficulty": "intermediate"
        }
      ]
    },
    {
      "id": "C03",
      "name": "Symbolic Register Usage",
      "definition": "Understanding symbolic registers and their role in state mutation.",
      "label": "Concept 3",
      "difficulty": "intermediate",
      "bloom_level": "Analyze",
      "prerequisites": ["C02"],
      "misconceptions": ["Register values are concrete by default"],
      "visibility": ["supervisor_agent", "instructor"],
      "validation_status": "pending",
      "confidence": 0.84,
      "relevance_score": 0.75,
      "source": "CTF_copy.pdf [page 15]",
      "learning_objective": "Manipulate symbolic registers to control path constraints.",
      "connections": [
        {"to": "C02", "relation": "EXTENDS_FROM"},
        {"to": "C04", "relation": "GENERALIZES_TO"}
      ],
      "children": [
        {
          "id": "P03",
          "name": "Procedural Steps: Symbolic Registers",
          "label": "Procedural Steps",
          "description": "Use symbolic registers to influence state transitions in angr.",
          "difficulty": "intermediate",
          "bloom_level": "Analyze",
          "common_errors": ["Incorrect register naming", "Assigning concrete values"],
          "success_criteria": [
            "Symbolic registers propagate through paths",
            "Solver can retrieve symbolic constraints"
          ],
          "error_patterns": ["SimStateError", "ClaripyTypeError"],
          "progress_metric": {"completed": false, "percent_done": 0},
          "children": [
            {
              "id": "P03-step1",
              "name": "Step 1: Access registers in state",
              "label": "Procedural Step 1",
              "code_snippet": "state.regs.eax",
              "hint": "Use state.regs.<register> to access symbolic registers.",
              "children": [
                {
                  "id": "P03-step2",
                  "name": "Step 2: Assign symbolic value",
                  "label": "Procedural Step 2",
                  "code_snippet": "state.regs.eax = claripy.BVS('eax', 32)",
                  "hint": "Use claripy bitvector for symbolic representation."
                }
              ]
            }
          ]
        },
        {
          "id": "A03",
          "name": "Assessment Guide: Symbolic Registers",
          "label": "Assessment 3",
          "linked_challenges": ["03_angr_symbolic_registers"],
          "objectives": ["Manipulate and inspect symbolic registers"],
          "question_prompts": [
            {"question": "What does assigning a claripy.BVS to a register enable?"},
            {"question": "Why might you need to reset symbolic registers?"}
          ],
          "evaluation_criteria": [
            "Symbolic propagation verified",
            "Solver produces expected model"
          ],
          "bloom_level": "Evaluate",
          "difficulty": "intermediate"
        }
      ]
    },
    {
      "id": "C04",
      "name": "Symbolic Stack Injection",
      "definition": "Technique for inserting symbolic values directly into the program stack to emulate runtime input parameters within functions.",
      "label": "Concept 4",
      "difficulty": "intermediate",
      "bloom_level": "Apply",
      "prerequisites": ["C02"],
      "misconceptions": [
        "ESP and EBP always point to the same address",
        "Stack injection automatically adjusts offsets"
      ],
      "visibility": ["supervisor_agent", "instructor"],
      "validation_status": "verified",
      "confidence": 0.9,
      "relevance_score": 0.87,
      "source": "CTF_copy.pdf [pages 32–34]",
      "learning_objective": "Set up stack frames manually to inject symbolic inputs at proper offsets for symbolic execution.",
      "connections": [
        {"to": "C03", "relation": "DEPENDS_ON"},
        {"to": "C05", "relation": "EXTENDS_TO"}
      ],
      "children": [
        {
          "id": "P04",
          "name": "Procedural Steps: Stack Injection",
          "label": "Procedural Steps",
          "description": "Manually configure the stack to inject symbolic bitvectors representing password bytes.",
          "difficulty": "intermediate",
          "bloom_level": "Apply",
          "common_errors": [
            "Incorrect padding between EBP and symbol start",
            "Pushing values before setting EBP=ESP"
          ],
          "success_criteria": [
            "Stack configured correctly with proper offsets",
            "Symbolic variables injected successfully"
          ],
          "error_patterns": ["SegmentationFault", "SymbolicMemoryError"],
          "progress_metric": {"completed": false, "percent_done": 0},
          "children": [
            {
              "id": "P04-step1",
              "name": "Step 1: Set starting address and initialize state",
              "label": "Procedural Step 1",
              "code_snippet": "initial_state = project.factory.blank_state(addr=start_address)",
              "hint": "Choose function start as symbolic execution entry.",
              "children": [
                {
                  "id": "P04-step2",
                  "name": "Step 2: Create symbolic bitvectors for each password",
                  "label": "Procedural Step 2",
                  "code_snippet": "password0 = claripy.BVS('password0', 32)",
                  "hint": "Use claripy.BVS for each password segment.",
                  "children": [
                    {
                      "id": "P04-step3",
                      "name": "Step 3: Align EBP and ESP registers",
                      "label": "Procedural Step 3",
                      "code_snippet": "state.regs.ebp = state.regs.esp",
                      "hint": "EBP must match ESP before pushing symbolic data.",
                      "children": [
                        {
                          "id": "P04-step4",
                          "name": "Step 4: Push symbolic variables to emulate input",
                          "label": "Procedural Step 4",
                          "code_snippet": "state.stack_push(password0)",
                          "hint": "Push symbolic passwords in correct order."
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        },
        {
          "id": "A04",
          "name": "Assessment Guide: Stack Injection",
          "label": "Assessment",
          "linked_challenges": ["04_angr_symbolic_stack"],
          "objectives": [
            "Manually configure symbolic stack values",
            "Understand offset alignment and register relationships"
          ],
          "question_prompts": [
            {"question": "Why must EBP and ESP be aligned before pushing symbols?"},
            {"question": "How do you compute padding between stack variables?"}
          ],
          "evaluation_criteria": [
            "Stack aligned and symbolic variables resolved",
            "Correct offsets maintained between pushes"
          ],
          "bloom_level": "Evaluate",
          "difficulty": "intermediate"
        }
      ]
    },
    {
      "id": "C05",
      "name": "Symbolic Memory Injection",
      "definition": "Method for writing symbolic values directly into global or heap memory to simulate complex input operations such as scanf.",
      "label": "Concept 5",
      "difficulty": "intermediate",
      "bloom_level": "Apply",
      "prerequisites": ["C04"],
      "misconceptions": [
        "Symbolic memory automatically overwrites previous data",
        "Memory and file symbolic spaces overlap"
      ],
      "visibility": ["supervisor_agent", "instructor"],
      "validation_status": "pending",
      "confidence": 0.89,
      "relevance_score": 0.84,
      "source": "CTF_copy.pdf [pages 35–37]",
      "learning_objective": "Apply symbolic memory injection to emulate user input routines like scanf.",
      "connections": [
        {"to": "C04", "relation": "DEPENDS_ON"},
        {"to": "C01", "relation": "USES_INIT_FROM"}
      ],
      "children": [
        {
          "id": "P05",
          "name": "Procedural Steps: Symbolic Memory Injection",
          "label": "Procedural Steps",
          "description": "Inject symbolic values directly into program memory at known addresses used by scanf or input routines.",
          "difficulty": "intermediate",
          "bloom_level": "Apply",
          "common_errors": ["Incorrect address or offset", "Concrete overwrite of symbolic data"],
          "success_criteria": [
            "Correct addresses identified for scanf parameters",
            "Symbolic values stored successfully in memory"
          ],
          "error_patterns": [
            "TypeError: expected bytes",
            "Memory write beyond allocated address"
          ],
          "progress_metric": {"completed": false, "percent_done": 0},
          "children": [
            {
              "id": "P05-step1",
              "name": "Step 1: Identify global or heap addresses written by scanf",
              "label": "Procedural Step 1",
              "code_snippet": "scanf('%u %u', &a, &b)",
              "hint": "Locate addresses where scanf stores input.",
              "children": [
                {
                  "id": "P05-step2",
                  "name": "Step 2: Write symbolic values to those addresses",
                  "label": "Procedural Step 2",
                  "code_snippet": "state.memory.store(0xaf84120, claripy.BVS('input_a', 32))",
                  "hint": "Use state.memory.store to place symbolic values."
                }
              ]
            }
          ]
        },
        {
          "id": "A05",
          "name": "Assessment Guide: Symbolic Memory Injection",
          "label": "Assessment 2",
          "linked_challenges": ["05_angr_symbolic_memory"],
          "objectives": [
            "Identify correct memory addresses for injection",
            "Apply symbolic memory stores correctly"
          ],
          "question_prompts": [
            {"question": "How do you locate scanf’s parameter addresses?"},
            {"question": "What happens if you overwrite symbolic memory with concrete values?"}
          ],
          "evaluation_criteria": [
            "Symbolic values stored in correct addresses",
            "Memory access remains valid during exploration"
          ],
          "bloom_level": "Evaluate",
          "difficulty": "intermediate"
        }
      ]
    }

  ]
}